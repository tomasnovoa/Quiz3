// PlanetsInit.compute
#pragma kernel InitPlanets

struct Planet {
    float4 posRad;   // xyz = position, w = radius
    float2 mass_pad; // x = mass, y = pad
};

RWStructuredBuffer<Planet> _Planets;

cbuffer Params {
    uint  _PlanetCount;
    float3 _AreaMin;
    float  _G_dummy;          // relleno para alineación
    float3 _AreaMax;
    float  _DeltaTime_dummy;  // relleno
    float2 _RadiusRange;
    float2 _ShipSpeedRange_dummy; // relleno
    float  _MassPerRadius;
    uint   _Seed;
    float  _Bounce_dummy;
    float  _Damping_dummy;
    float  _MinDist_dummy;
};

uint Hash(uint x) {
    x ^= 2747636419u; x *= 2654435769u;
    x ^= x >> 16;     x *= 2654435769u;
    x ^= x >> 16;     x *= 2654435769u;
    return x;
}
float Rand01(inout uint s) { s = Hash(s); return (s & 0x00FFFFFFu) / 16777216.0; }
float3 RandInBox(inout uint s, float3 mn, float3 mx) {
    return float3(lerp(mn.x, mx.x, Rand01(s)),
                  lerp(mn.y, mx.y, Rand01(s)),
                  lerp(mn.z, mx.z, Rand01(s)));
}

[numthreads(64,1,1)]
void InitPlanets(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _PlanetCount) return;
    uint state = _Seed + 93463u * (id.x + 1u);

    float3 pos = RandInBox(state, _AreaMin, _AreaMax);
    float  rad = lerp(_RadiusRange.x, _RadiusRange.y, Rand01(state));
    float  mass = max(0.0, rad * _MassPerRadius);

    Planet p;
    p.posRad  = float4(pos, rad);
    p.mass_pad = float2(mass, 0.0);
    _Planets[id.x] = p;
}

